<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Perspective Photo Clip Art</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        h1 {
            width: 100%;
            text-align: center;
            padding:30px;
            margin:0;
            /* background-color:#ccc; */
        }
        canvas {
            display: inline-block;
        }
        .next-element {
            margin-top: 0;
        }

        div.title {
            float: left;
            padding-top: 10px;
            padding-bottom: 10px;
            background-color: aliceblue;
            width: 50%;
            text-align: center;
            line-height: 1.2;
        }
        .title:hover {
            background-color: rgb(205, 231, 255)
        }

        input[type="file"] {
            display:none;
        }
        .file-upload {
            background-color:white;
            display: inline-block;
            border-radius: 20px;
            padding: 20px 10px;
            width:100px;
            cursor: pointer;
            text-transform: uppercase;
        }
        .file-upload:hover {
            background-color: black;
            color: white;
        }

        span.title {
            font-size: large;
            font-weight: bold;
        }
        .container {
            clear:both;
            display: flex;
            flex-basis: auto;
        }
        #background-container {
            /* visibility: hidden; */
            display:inline-block;
            /* float: left; */
            align-items: center;
            text-align: center;
            margin: 0;
            width: 100%;
        }
        #object-container {
            /* visibility: hidden; */
            display:none;
            align-items: center;
            text-align: center;
            margin: 0;
            width: 100%;
        }

        .alert-text {
            background-color: black;
            color: white;
            display: inline-block;
            border: 2px outset #000;
            width: 100%;
            padding: 5px;
            text-align: center;
            box-sizing: border-box;
        }

        .radio-container {
            padding: 30px 0px;
            font-size: 20px;
            cursor: pointer;
        }
        .radio-container input {
            position: absolute;
            visibility: hidden;
        }
        .axis{
            display:inline-block;
            padding: 10px 0px;          
            text-align:center;
            /* float: left; */
            width: 20%;
            padding: 15px 0px;;
            border-radius: 25px;
        }
        #x {
            background-color: rgb(255, 211, 211) ;
            transition: background-color 0.1s, color 0.1s;
        }
        #x:hover, .radio-container input:checked ~ #x {
            background-color: rgb(255, 50, 50);
            color: white;
        }
        #y {
            background-color: rgb(211, 255, 211); 
            transition: background-color 0.1s, color 0.1s;
        }
        #y:hover, .radio-container input:checked ~ #y {
            background-color: rgb(50, 255, 50);
        }
        #z {
            background-color: rgb(211, 211, 255);
            transition: background-color 0.1s, color 0.1s;
        }
        #z:hover, .radio-container input:checked ~ #z {
            background-color: rgb(50, 50, 255);
            color: white;
        }
        #height {
            background-color: rgb(255, 217, 159);
            transition: background-color 0.1s, color 0.1s;
        }
        #height:hover, .radio-container input:checked ~ #height {
            background-color: rgb(255, 128, 50);
        }
        .tools {
            display: inline-block;
            padding: 10px 0px;
            text-align:center;
            border-style: solid;
            border-color: white;
            border-width: 2px;
            /* float: left; */
            width: calc(80% / 3 - 2px * 2);
            padding: 15px 0px;
            transition: background-color 0.1s, border-color 0.1s;
        }
        .tools:hover {
            border-style: solid;
            border-color: rgb(202, 202, 179);
            border-width: 2px;
            background-color: beige;
            cursor: pointer;
        }

        input[type="number"] {
            width: 15%;
            height: 30px;
        }

        div.done {
            margin-top:40px;
            padding-top: 10px;
            padding-bottom: 10px;
            text-align: center;
        }
        input[type="button"] {
            display:none;
        }
        .doneButton {
            text-align:center;
            background-color:rgb(100,100,100);
            border-style:solid;
            border-width: 5px;
            border-color: rgb(206, 206, 206);
            color:white;
            border-radius:25px;
            padding:30px;
        }
        .doneButton:hover {
            background-color:gray;
            cursor:pointer;
        }

        
    </style>
    <script type="module" src="https://pyscript.net/releases/2024.5.1/core.js"></script>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" type="text/javascript"></script>
<body>
    <h1>Perspective Photo Clip Art</h1>

    <div class="title" id="background-title">
    <span class="title">Background Image</span>
    <br>
    <label for="background-image-load" class="file-upload">Load</label>
    <input type="file" accept="image/*" onchange="loadBackground(event)" id="background-image-load">
    <label for="background-image-edit" class="file-upload">Edit</label>
    <input type="button" id="background-image-edit" onclick="editBackground()">

    </div>

    <div class="title" id="object-title">
    <span class="title">Object Image</span>
    <br>
    <label for="object-image" class="file-upload">Load</label>
    <input type="file" accept="image/*" onchange="loadObject(event)" id="object-image">
    <label for="object-image-edit" class="file-upload">Edit</label>
    <input type="button" id="object-image-edit" onclick="editObject()">
    </div>

    <div class="container">
        <div id="background-container">
            <span class="alert-text">You can click on image to set axis</span>

            <canvas id="background-canvas"></canvas>

            <div class="radio">
                <label class="radio-container">
                    <input type="radio" name="background-axis" value="x-axis" checked> <span class="axis" id="x">x-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="background-axis" value="y-axis"> <span class="axis" id="y">y-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="background-axis" value="z-axis"> <span class="axis" id="z">z-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="background-axis" value="height"> <span class="axis" id="height">height</span>
                </label>
            </div>

            <div>
            <label for="background-undo" class="tools">Undo</label>
            <input type="button" name="background-axis" value="undo" class="undo" id="background-undo" onclick="backgroundUndo()">

            <!--input type="button" name="background-axis" value="recommended corners" onclick="backgroundCornerDetection()"-->

            <label for="background-recommend" class="tools">Recommended Lines</label>
            <input type="button" name="background-axis" value="recommended lines" class="recommend" id="background-recommend" onclick="backgroundLineDetection()">

            <label for="background-return" class="tools">Back to Canvas</label>
            <input type="button" name="background-axis" value="back to canvas" class="return" id="background-return" onclick="backToCanvas()">
            </div>

            <input type="number" id="background-height" onchange="backgroundHeightValueChange()" placeholder="Background height">
            
        </div>

        <div id="object-container">
            <span class="alert-text">First, select the origin point</span>
            <canvas id="object-canvas"></canvas>
            
            <div class="radio">
                <label class="radio-container">
                    <input type="radio" name="object-axis" value="x-axis" checked> <span class="axis" id="x">x-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="object-axis" value="y-axis"> <span class="axis" id="y">y-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="object-axis" value="z-axis"> <span class="axis" id="z">z-axis</span>
                </label>
                <label class="radio-container">
                    <input type="radio" name="object-axis" value="height"> <span class="axis" id="height">height</span>
                </label>
            </div>

            <div>
            <label for="object-undo" class="tools">Undo</label>
            <input type="button" name="object-axis" value="undo" class="undo" id="object-undo" onclick="objectUndo()">

            <!--input type="button" name="object-axis" value="recommended corners" onclick="objectCornerDetection()"-->

            <label for="object-recommend" class="tools">Recommended Lines</label>
            <input type="button" name="object-axis" value="recommended lines" class="recommend" id="object-recommend" onclick="objectLineDetection()">

            <label for="object-return" class="tools">Back to Canvas</label>
            <input type="button" name="object-axis" value="back to canvas" class="return" id="object-return" onclick="backToCanvas()">

            </div>

            <input type="number" id="object-height" onchange="objectHeightValueChange()" placeholder="Object height">
        </div>
    </div>

    <div id="python-event"></div>

    <div class="done">
    <label for="done" class="doneButton">Done!</label>
    <input type="button" value="done" onclick="getResult()" id="done">
    </div>

    <script>
        const inputMode = {
            x: 0,
            y: 1,
            z: 2,
            origin: 4,
            height: 5
        }
        

        var backgroundCanvas = document.getElementById("background-canvas")
        var objectCanvas = document.getElementById("object-canvas")
        var resultCanvas = document.getElementById("result-canvas")

        backgroundCanvas.addEventListener("mousedown", function(event){backgroundDown(event)}, false)
        backgroundCanvas.addEventListener("mousemove", function(event){backgroundMove(event)}, false)

        objectCanvas.addEventListener("mousedown", function(event){objectDown(event)}, false)
        objectCanvas.addEventListener("mousemove", function(event){objectMove(event)}, false)

        var backgroundImage = undefined
        var objectImage = undefined

        var backgroundImage_save = undefined
        var objectImage_save = undefined

        var backgroundImage_prev = []
        var objectImage_prev = []

        var backgroundAdded = []
        var objectAdded = []

        var backgroundImageBase64 = undefined
        var objectImageBase64 = undefined
        var newImage = undefined
        var newImageBase64 = undefined

        var backgroundAlert = document.getElementsByClassName("alert-text")[0]
        var background_areLinesRecommended = false
        var background_recommendedLines = undefined

        var backgroundX = []
        var backgroundY = []
        var backgroundZ = []
        var backgroundHeight = undefined
        var backgroundHeightValue = undefined
        var backgroundAxis = inputMode.x
        var backgroundP = null
        
        var objectX = []
        var objectY = []
        var objectZ = []
        var objectHeight = undefined
        var objectHeightValue = undefined
        var objectAxis = inputMode.x
        var objectOrigin = undefined
        var objectP = null

        const python = new Event("python")
        const pythonEvent = document.getElementById("python-event")

        function backgroundInit() {
            backgroundX = []
            backgroundY = []
            backgroundZ = []
            backgroundHeight = undefined
            backgroundHeightValue = undefined
            backgroundAxis = inputMode.x
            backgroundP = null

            background_areLinesRecommended = false
            background_recommendedLines = undefined

            // document.getElementById("background-recommend").style.display = "inline"
            // document.getElementById("background-return").style.display = "none"

            backgroundImage_save = undefined
            backgroundImage_prev = []
            backgroundAdded = []

            backgroundAlert.style.color = "white"
            backgroundAlert.innerText = "You can click on image to set axis"
        }

        function objectInit() {
            objectX = []
            objectY = []
            objectZ = []
            objectHeight = undefined
            objectHeightValue = undefined
            objectAxis = inputMode.x
            objectOrigin = undefined
            objectP = null
        }

        function backgroundHeightValueChange() {
            backgroundHeightValue = Number(document.getElementById("background-height").value)
        }

        function objectHeightValueChange() {
            objectHeightValue = Number(document.getElementById("object-height").value)
        }

        function editBackground() {
            document.getElementById("background-container").style.display = "inline-block"
            document.getElementById("object-container").style.display = "none"
            document.getElementById("background-title").style.color = "blue"
            document.getElementById("object-title").style.color = "black"
        }

        function editObject() {
            document.getElementById("background-container").style.display = "none"
            document.getElementById("object-container").style.display = "inline-block"
            document.getElementById("background-title").style.color = "black"
            document.getElementById("object-title").style.color = "blue"
        }

        // from https://gist.github.com/jwir3/d797037d2e1bf78a9b04838d73436197
        function drawArrowhead(canvas, ends, radius, color) {
            var context = canvas.getContext("2d")

            var from = ends[0]
            var to = ends[1]

            var angle
            var x
            var y

            context.beginPath()

            margin = 0.2
            angle = Math.atan2(to[1] - from[1], to[0] - from[0])
            var x_center = to[0] - radius * Math.cos(angle) * (1 - margin)
            var y_center = to[1] - radius * Math.sin(angle) * (1 - margin)

            x = to[0] + radius * Math.cos(angle) * margin
            y = to[1] + radius * Math.sin(angle) * margin

            context.moveTo(x, y)

            angle += (1.0/3.0) * (2 * Math.PI)
            x = radius * Math.cos(angle) + x_center
            y = radius * Math.sin(angle) + y_center

            context.lineTo(x, y)

            angle += (1.0/3.0) * (2 * Math.PI)
            x = radius * Math.cos(angle) + x_center
            y = radius * Math.sin(angle) + y_center

            context.lineTo(x, y)

            context.closePath()

            context.fillStyle = color

            context.fill()
        }

        function drawLine(canvas, ends, color) {
            var ctx = canvas.getContext("2d")

            ctx.beginPath()
            ctx.moveTo(ends[0][0], ends[0][1])
            ctx.lineTo(ends[1][0], ends[1][1])
            ctx.lineWidth = 3
            ctx.strokeStyle = color
            ctx.stroke()
        }

        function drawPoint(canvas, point, color) {
            var ctx = canvas.getContext("2d")

            ctx.fillRect(point[0] - 3, point[1] - 3, 6, 6)
        }
        
        function returnMode(mode) {
            // Can be used for both background and object
            var axisMode
            switch(mode) {
                case "x-axis":
                    axisMode = inputMode.x
                    break
                case "y-axis":
                    axisMode = inputMode.y
                    break
                case "z-axis":
                    axisMode = inputMode.z
                    break
                case "height":
                    axisMode = inputMode.height
                    break
            }
            return axisMode
        }

        function setBackgroundAlertColor(backgroundMode) {
            switch(backgroundMode) {
            case inputMode.x:
                backgroundAlert.style.color = "red"
                break
            case inputMode.y:
                backgroundAlert.style.color = "green"
                break
            case inputMode.z:
                backgroundAlert.style.color = "blue"
                break
            case inputMode.height:
                backgroundAlert.style.color = "orange"
            }
        }

        function backgroundUndo() {
            if (backgroundP === null && backgroundImage_prev.length > 0 && !background_areLinesRecommended) {
                backgroundMode = backgroundAdded.slice(-1)[0]
                setBackgroundAlertColor(backgroundMode)
                switch(backgroundMode) {
                case inputMode.x:
                    backgroundAlert.innerText = 'x-axis deleted'
                    backgroundX.splice(-1, 1)
                    break
                case inputMode.y:
                    backgroundY.splice(-1, 1)
                    backgroundAlert.innerText = 'y-axis deleted'
                    break
                case inputMode.z:
                    backgroundZ.splice(-1, 1)
                    backgroundAlert.innerText = 'z-axis deleted'
                    break
                case inputMode.height:
                    backgroundHeight = undefined
                    backgroundHeightValue = undefined
                    backgroundAlert.innerText = 'Height deleted'
                    break
                }
                prev_image = backgroundImage_prev.slice(-1)[0]
                ctx = backgroundCanvas.getContext("2d")
                ctx.putImageData(prev_image, 0, 0)
                backgroundImage_save = ctx.getImageData(0, 0, backgroundImage.width, backgroundImage.height)    

                backgroundImage_prev.splice(-1, 1)
                backgroundAdded.splice(-1, 1)

                console.log(backgroundAdded)
            }
        }

        function backgroundDown(event) {
            if (background_areLinesRecommended) {
                const rect = backgroundCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                clickedLineIndex = closestLineIndex(mouseX, mouseY)
                if (clickedLineIndex != -1) {
                    console.log('here')
                    var mode = document.querySelector("input[name=\"background-axis\"]:checked").value
                    var backgroundMode = returnMode(mode)
                    color = inputColor(backgroundMode)
                    
                    ctx = backgroundCanvas.getContext('2d')
                    ctx.putImageData(backgroundImage_save, 0, 0)
                    // console.log(background_recommendedLines)
                    // console.log(clickedLineIndex)
                    nearest_line = background_recommendedLines[clickedLineIndex]

                    var color = undefined
                    if (backgroundMode == inputMode.height) {
                        if (backgroundHeight === undefined) {
                            color = "orange"
                            if (nearest_line[1] > nearest_line[3])
                                backgroundHeight = [[nearest_line[0], nearest_line[1]], [nearest_line[2], nearest_line[3]]]
                            else 
                                backgroundHeight = [[nearest_line[2], nearest_line[3]], [nearest_line[0], nearest_line[1]]]
                            drawLines(ctx, [nearest_line], color)
                            drawArrowhead(backgroundCanvas, backgroundHeight, 10, "orange")

                            backgroundAdded.push(backgroundMode)
                            backgroundImage_prev.push(backgroundImage_save)
                            backgroundImage_save = ctx.getImageData(0, 0, backgroundImage.width, backgroundImage.height)    
                        }
                    }
                    else {           
                    switch(backgroundMode) {
                        case inputMode.x:
                            color = "red"
                            backgroundX.push(nearest_line)
                            break
                        case inputMode.y:
                            color = "green"
                            backgroundY.push(nearest_line)
                            break
                        case inputMode.z:
                            color = "blue"
                            backgroundZ.push(nearest_line)
                            break
                        }
                        drawLines(ctx, [nearest_line], color)

                        backgroundAdded.push(backgroundMode)
                        backgroundImage_prev.push(backgroundImage_save)
                        backgroundImage_save = ctx.getImageData(0, 0, backgroundImage.width, backgroundImage.height) 
                    }

                    background_areLinesRecommended = false
                    
                    console.log(backgroundAdded)

                    // document.getElementById("background-recommend").style.display = "inline"
                    // document.getElementById("background-return").style.display = "none"
                    
                    setBackgroundAlertColor(backgroundMode)
                    backgroundAlert.innerText = 'Line Drawn'
                }
            }
            else {
                var mode = document.querySelector("input[name=\"background-axis\"]:checked").value
                var backgroundMode = returnMode(mode)
                setBackgroundAlertColor(backgroundMode)
                if (backgroundP === null) {
                    if (backgroundMode != inputMode.height || (backgroundMode == inputMode.height && backgroundHeight === undefined)) {
                        backgroundP = [event.offsetX, event.offsetY]
                        
                        backgroundAlert.innerText = 'Start point clicked'

                        save_img = backgroundCanvas.getContext("2d").getImageData(0, 0, backgroundImage.width, backgroundImage.height)
                        backgroundImage_save = save_img
                        backgroundImage_prev.push(save_img)
                    }
                    else {
                        backgroundAlert.style.color = "red"
                        backgroundAlert.innerText = "Height can be selected only once!"
                    }
                } 
                else {    
                    var backgroundQ = [event.offsetX, event.offsetY]
                    var line = [backgroundP, backgroundQ]
                
                    switch(backgroundMode) {
                    case inputMode.x:
                        backgroundX.push(line)
                        drawLine(backgroundCanvas, [backgroundP, backgroundQ], "red")
                        break
                    case inputMode.y:
                        backgroundY.push(line)
                        drawLine(backgroundCanvas, [backgroundP, backgroundQ], "green")
                        break
                    case inputMode.z:
                        backgroundZ.push(line)
                        drawLine(backgroundCanvas, [backgroundP, backgroundQ], "blue")
                        break
                    case inputMode.height:
                        if (backgroundHeight === undefined) {
                            backgroundHeight = line
                            drawLine(backgroundCanvas, backgroundHeight, "orange")
                            drawArrowhead(backgroundCanvas, backgroundHeight, 10, "orange")
                        }
                        break
                    }

                    console.log(line)

                    backgroundAdded.push(backgroundMode)
                    console.log(backgroundAdded)
                    backgroundImage_save = backgroundCanvas.getContext("2d").getImageData(0, 0, backgroundImage.width, backgroundImage.height)    
                    
                    backgroundP = null
                    backgroundAlert.innerText = 'End point clicked, Line Drawn'
                }
            }
        }

        function backgroundMove(event) {
            if (background_areLinesRecommended) {
                const rect = backgroundCanvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                highlightClosestLine(canvas, mouseX, mouseY);
            }
            else if (backgroundP !== null) {
                var mode = document.querySelector("input[name=\"background-axis\"]:checked").value
                var backgroundMode = returnMode(mode)
                var backgroundQ = [event.offsetX, event.offsetY]
                
                backgroundCanvas.getContext("2d").putImageData(backgroundImage_save, 0, 0)

                switch(backgroundMode) {
                case inputMode.x:
                    drawLine(backgroundCanvas, [backgroundP, backgroundQ], "red")
                    break
                case inputMode.y:
                    drawLine(backgroundCanvas, [backgroundP, backgroundQ], "green")
                    break
                case inputMode.z:
                    drawLine(backgroundCanvas, [backgroundP, backgroundQ], "blue")
                    break
                case inputMode.height:
                    backgroundHeight_temp = [backgroundP, backgroundQ]
                    drawLine(backgroundCanvas, backgroundHeight_temp, "orange")
                    drawArrowhead(backgroundCanvas, backgroundHeight_temp, 10, "orange")
                    break
                }
            }
        }
        
        function grayscale(imageData) {
            const grayImageData = new ImageData(imageData.width, imageData.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const avg = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                grayImageData.data[i] = avg;
                grayImageData.data[i + 1] = avg;
                grayImageData.data[i + 2] = avg;
                grayImageData.data[i + 3] = imageData.data[i + 3];
            }
            return grayImageData;
        }
        function applyCannyEdgeDetection(grayImageData) {
            // Convert ImageData to cv.Mat
            const src = cv.matFromImageData(grayImageData);

            // Apply Canny edge detection
            const dst = new cv.Mat();
            cv.Canny(src, dst, 300, 400, 3, false);

            // Convert the result back to ImageData
            const edgesImageData = new ImageData(dst.cols, dst.rows);
            for (let i = 0; i < dst.data.length; i++) {
                edgesImageData.data[i * 4] = dst.data[i];
                edgesImageData.data[i * 4 + 1] = dst.data[i];
                edgesImageData.data[i * 4 + 2] = dst.data[i];
                edgesImageData.data[i * 4 + 3] = 255; // Fully opaque
            }
            // Release memory
            src.delete();
            dst.delete();

            return edgesImageData;
        }
        
        function applyHoughTransform(edgesImageData) {
            // Convert ImageData to cv.Mat
            const src = cv.matFromImageData(edgesImageData);
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            // Apply Hough Transform
            const lines = new cv.Mat();
            const rho = 1; // Distance resolution in pixels
            const theta = Math.PI / 180; // Angle resolution in radians
            const threshold = 100; // Accumulator threshold parameter, you can adjust this
            const minLineLength = 30; // Minimum line length. Line segments shorter than this are rejected
            const maxLineGap = 1; // Maximum allowed gap between points on the same line to link them

            cv.HoughLinesP(src, lines, rho, theta, threshold, minLineLength, maxLineGap);

            const linesArray = [];
            for (let i = 0; i < lines.rows; ++i) {
                const x1 = lines.data32S[i * 4];
                const y1 = lines.data32S[i * 4 + 1];
                const x2 = lines.data32S[i * 4 + 2];
                const y2 = lines.data32S[i * 4 + 3];
                linesArray.push([x1, y1, x2, y2]);
            }
            src.delete();
            lines.delete();
            return linesArray;
        }

        function drawLines(ctx, lines, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            for (const line of lines) {
                const [x1, y1, x2, y2] = line;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        function backgroundLineDetection() {
            if (!background_areLinesRecommended) {
                background_areLinesRecommended = true
                // document.getElementById("background-recommend").style.display = "none"
                // document.getElementById("background-return").style.display = "inline"
                
                canvas = document.getElementById('background-canvas')
                ctx = canvas.getContext("2d")
                if (background_recommendedLines === undefined) {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const grayImageData = grayscale(imageData);
                    const edgesImageData = applyCannyEdgeDetection(grayImageData);
                    // ctx.putImageData(edgesImageData, 0, 0)
                    const lines = applyHoughTransform(edgesImageData);

                    background_recommendedLines = lines
                }
                save_img = backgroundCanvas.getContext("2d").getImageData(0, 0, backgroundImage.width, backgroundImage.height)
                backgroundImage_save = save_img
                // backgroundImage_prev.push(save_img)

                drawLines(ctx, background_recommendedLines, 'yellow');

                backgroundAlert.style.color = "white"
                backgroundAlert.innerText = 'These are some recommended lines'
            }
            else {
                backgroundAlert.style.color = "white"
                backgroundAlert.innerText = 'Lines are already recommended.'
            }
        }

        function backToCanvas() {
            if (background_areLinesRecommended) {
                ctx = backgroundCanvas.getContext("2d")
                ctx.putImageData(backgroundImage_save, 0, 0)

                // document.getElementById("background-recommend").style.display = "inline"
                // document.getElementById("background-return").style.display = "none"

                background_areLinesRecommended = false

                backgroundAlert.style.color = "white"
                backgroundAlert.innerText = 'Back to Canvas'
            }
            else {
                backgroundAlert.style.color = "white"
                backgroundAlert.innerText = 'Use this button after using Recommended Lines button'
            }
        }
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const l2 = dx * dx + dy * dy;
            if (l2 === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            var t = ((px - x1) * dx + (py - y1) * dy) / l2;
            t = Math.max(0, Math.min(1, t));
            const x = x1 + t * dx;
            const y = y1 + t * dy;
            return Math.sqrt((px - x) ** 2 + (py - y) ** 2);
        }

        function inputColor(mode) {
            var color = undefined
            switch(mode) {
            case inputMode.x:
                color = "red"
                break
            case inputMode.y:
                color = "green"
                break
            case inputMode.z:
                color = "blue"
                break
            case inputMode.height:
                color="orange"
                break
            }
            return color
        }

        function closestLineIndex(mouseX, mouseY) {
            highlightedLineIndex = -1;
            let minDistance = Infinity;

            for (let i = 0; i < background_recommendedLines.length; i++) {
                const [x1, y1, x2, y2] = background_recommendedLines[i];
                const distance = pointToLineDistance(mouseX, mouseY, x1, y1, x2, y2);
                if (distance < 5 && distance < minDistance) {
                    minDistance = distance;
                    highlightedLineIndex = i;
                }
            }
            return highlightedLineIndex
        }

        function highlightClosestLine(canvas, mouseX, mouseY) {
            var mode = document.querySelector("input[name=\"background-axis\"]:checked").value
            var backgroundMode = returnMode(mode)
            color = inputColor(backgroundMode)
            
            ctx = canvas.getContext('2d')
            ctx.putImageData(backgroundImage_save, 0, 0)
            drawLines(ctx, background_recommendedLines, "yellow");
            highlightedLineIndex = closestLineIndex(mouseX, mouseY)
            nearest_line = background_recommendedLines[highlightedLineIndex]
            if (highlightedLineIndex != -1) 
                drawLines(ctx, [nearest_line], color);
        }
        

        // This is not very efficient to use
        function backgroundCornerDetection() {
            try {
                canvas = document.getElementById('background-canvas')
                console.log('Canvas element:', canvas);
                const src = cv.imread(canvas);
                if (src.empty()) {
                    throw new Error('Failed to read image data from canvas.');
                }
                console.log('Image read into cv.Mat object.');

                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                console.log('Image converted to grayscale.');

                const corners = new cv.Mat();
                cv.cornerHarris(gray, corners, 3, 3, 0.03);
                console.log('Harris Corner Detection applied.');

                const dst = new cv.Mat();
                cv.normalize(corners, dst, 0, 255, cv.NORM_MINMAX);
                console.log('Corners normalized.');
                
                const threshold = 80
                
                function isCloseToRed(r, g, b) {
                    // Define threshold values for red-like colors in RGB space
                    const redThreshold = 100;
                    const greenThreshold = 80;
                    const blueThreshold = 80;

                    // Check if the pixel color is within the thresholds for red-like colors
                    return r > redThreshold && g < greenThreshold && b < blueThreshold;
                }

                function isCloseToRedWithSurroundings(canvas, x, y, radius) {
                    // Get the canvas context
                    const ctx = canvas.getContext('2d');

                    // Define a region around the point
                    const imageData = ctx.getImageData(x - radius, y - radius, 2 * radius, 2 * radius);
                    const data = imageData.data;

                    // Iterate over the pixels in the region
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        // Check if the pixel color is close to red-like
                        if (isCloseToRed(r, g, b)) {
                            return true; // Return true if at least one red-like pixel is found
                        }
                    }
                }

                for (let i = 0; i < dst.rows; i++) {
                    for (let j = 0; j < dst.cols; j++) {
                        if (dst.floatAt(i, j) > threshold) {
                            const isRedLike = isCloseToRedWithSurroundings(canvas, j, i, 2);

                            const color = isRedLike ? [0, 255, 0, 255] : [255, 0, 0, 255];
                            cv.circle(src, new cv.Point(j, i), 2, color, -1, cv.LINE_AA, 0);
                        }
                    }
                }
                
                const imageData = new ImageData(new Uint8ClampedArray(src.data), src.cols, src.rows)
                canvas.getContext("2d").putImageData(imageData, 0, 0);
                console.log('Result displayed on canvas.');

                src.delete();
                gray.delete();
                corners.delete();
                dst.delete();
            } catch (err) {
                console.error('Error during Harris Corner Detection:', err);
            }
        }

        function objectDown(event) {
            if (objectP === null) {
                objectP = [event.offsetX, event.offsetY]
                console.log('Start point clicked')
                objectImage_save = objectCanvas.getContext("2d").getImageData(0, 0, objectImage.width, objectImage.height)
            } 
            else { 
                var mode = document.querySelector("input[name=\"object-axis\"]:checked").value
                var objectMode = returnMode(mode)
                var objectQ = [event.offsetX, event.offsetY]
                
                switch(objectMode) {
                case inputMode.x:
                    objectX.push([objectP, objectQ])
                    drawLine(objectCanvas, [objectP, objectQ], "red")
                    break
                case inputMode.y:
                    objectY.push([objectP, objectQ])
                    drawLine(objectCanvas, [objectP, objectQ], "green")
                    break
                case inputMode.z:
                    objectZ.push([objectP, objectQ])
                    drawLine(objectCanvas, [objectP, objectQ], "blue")
                    break
                case inputMode.height:
                    if (objectHeight === undefined) {
                        objectHeight = [objectP, objectQ]
                        drawLine(objectCanvas, objectHeight, "black")
                        drawArrowhead(objectCanvas, objectHeight, 10)
                    }
                    break
                }

                objectP = null
                objectImage_save = objectCanvas.getContext("2d").getImageData(0, 0, objectImage.width, objectImage.height)
                console.log('End point clicked, Line Drawn')
            }
        }

        function objectMove(event) {
            if (objectP !== null) {
                var mode = document.querySelector("input[name=\"object-axis\"]:checked").value
                var objectMode = returnMode(mode)
                var objectQ = [event.offsetX, event.offsetY]
                
                objectCanvas.getContext("2d").putImageData(objectImage_save, 0, 0)

                switch(objectMode) {
                case inputMode.x:
                    drawLine(objectCanvas, [objectP, objectQ], "red")
                    break
                case inputMode.y:
                    drawLine(objectCanvas, [objectP, objectQ], "green")
                    break
                case inputMode.z:
                    drawLine(objectCanvas, [objectP, objectQ], "blue")
                    break
                case inputMode.height:
                    objectHeight = [objectP, objectQ]
                    drawLine(objectCanvas, objectHeight, "black")
                    drawArrowhead(objectCanvas, objectHeight, 10)
                    break
                }
            }
        }

        function loadBackground(event) {
            background_p = undefined
            
            editBackground()
            backgroundImage = new Image()
            backgroundImage.addEventListener('load', function() {
                // backgroundCanvas.width = 500
                // backgroundCanvas.height = Number(500 * backgroundImage.height / backgroundImage.width)

                if (backgroundImage.width > window.innerWidth) {
                    backgroundCanvas.width = window.innerWidth
                    backgroundCanvas.height = Number(backgroundCanvas.width * backgroundImage.height / backgroundImage.width)
                }
                else {
                    backgroundCanvas.width = backgroundImage.width
                    backgroundCanvas.height = backgroundImage.height
                }
                backgroundCanvas.getContext("2d").drawImage(backgroundImage, 0, 0, backgroundCanvas.width, backgroundCanvas.height)


            })
            backgroundImage.src = URL.createObjectURL(event.target.files[0])
            backgroundInit()
        }
        
        function loadObject(event) {
            editObject()
            objectImage = new Image()
            objectImage.addEventListener('load', function() {
                // objectCanvas.width = 500
                // objectCanvas.height = Number(500 * objectImage.height / objectImage.width)

                if (objectImage.width > window.innerWidth) {
                    objectCanvas.width = window.innerWidth
                    objectCanvas.height = Number(objectCanvas.width * objectImage.height / objectImage.width)
                }
                else {
                    objectCanvas.width = objectImage.width
                    objectCanvas.height = objectImage.height
                }

                objectCanvas.getContext("2d").drawImage(objectImage, 0, 0, objectCanvas.width, objectCanvas.height)
            })
            objectImage.src = URL.createObjectURL(event.target.files[0])
            objectInit()
        }

        async function getResult() {
            if (backgroundImage === undefined || objectImage === undefined) {
                alert("You must input both background and object images")
                return
            }

            if (backgroundX.length < 2 || backgroundY.length < 2 || backgroundZ.length < 2 ||
                objectX.length < 2 || objectY.length < 2 || objectZ.length < 2) {
                alert("You must input at least two lines for all axes")
                return
            }

            if (backgroundHeight === undefined || backgroundHeightValue === undefined) {
                alert("You must input height information")
                return
            }

            pythonEvent.dispatchEvent(python)
        }
    </script>
    
    <script type="py" src="./event_handler.py" config="pyscript.toml"></script>
</body>
</head>
</html>